---
title: "Explanation of High Dimensional Gene Knockout Simulations"
author: "James Long"
always_allow_html: yes
date: "`r Sys.Date()`"
output:
  html_document:
    theme: united
    toc: yes
    toc_collapsed: yes
    toc_float: yes
---

```{r alternative-preambles,echo=FALSE,include=FALSE,eval=FALSE}
## add date
date: "05/20/2020"

## if using word replace output with
output:
  word_document:
    toc: yes

## if using pdf replace output with
output:
  pdf_document:
    toc: yes
header-includes:
  - \usepackage{xcolor}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## colorizes text when using html or pdf output
## just spits out text x for word
colorize <- function(x, color) {
  if(color=="todo"){
    color <- "red"
    x <- paste0("TODO: ",x)
  }
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
      x)
  } else x
}

todo <- function(x){
  paste0("**",colorize(x,"todo"),"**")
}

library(ggplot2)
library(parallel)
set.seed(1)
```

## Overview

This document describes the simulation parameters and code used for the high dimensional knockout simulations in the manuscript. Here simulation results are only produced for a small version of the simulation. Reproducing full results requires a high performance computing facility. See the README file in this repository for how to run that pipeline.

These simulations studied the performance of some Two Stage Least Squares estimators which were not shown in the manuscript.

## Simulation Parameters

We suppose a set of $p+1$ genes $X$ with response $Y = X_{p/2+1}$ and set our goal to determine the causal effect of $X_1,\ldots,X_p$ on $Y$. We assume the availability of observational and knockout data. Our model is

$$
\bf{X} = \bf{E}\bf{Q} + \bf{X}\bf{A} + \bf{\delta}_X
$$
where 

* $X \in \mathbb{R}^{n \times (p+1)}$ are n observations of gene expression
* $E \in \mathbb{R}^{n \times q}$ is a knockout matrix with $E_{ij}$ indicating whether gene $j$ was knocked out in sample $i$
* $Q$ denotes how knockouts effect $X$. $Q_{ij}$ is the causal effect of knockout $i$ on gene $j$.
* $A$ denotes causal structure within $X$. $A_{ii}$ is $0$ (no self causality) and $A$ forms a directed acyclic graph. Entry $A_{ij}$ is the causal effect of $X_i$ on $X_j$ (the coefficient in the DAG from node $i$ to $j$). Thus the causal parameter of interest is $\beta = (A_{1,p+1},\ldots,A_{p,p+1})$
* $\epsilon_X \sim N(0,\Sigma)$ models unobserved confounders.


### IV Model Parameterization

Let $\bf{Y}$ ($\bf{\delta_Y}$) be the $p/2+1$ column of $\bf{X}$ ($\bf{\epsilon}_X$). Finally let $\bf{X}_{-Y}$ be $\bf{X}$ with the $p/2+1$ column removed. Let $\beta^T = (A_{1,p/2+1},\ldots,A_{p/2+1,p/2+1},A_{p/2+1,p/2+2},\ldots,A_{p/2+1,p+1})$ be the $p/2+1$ column of $A$ with the $A_{p/2+1,p/2+1}$ element removed. Then
$$
\bf{Y} = \bf{X}_{-Y}\beta + \delta_{Y}.
$$
Here $\bf{X}_{-Y}$ and $\delta_{Y}$ are dependent, so regression of $\bf{Y}$ on $\bf{X}_{-Y}$ results in inconsistent estimates of $\beta$. The instrument model can be derived by first noting that
$$
\bf{X} = \bf{E}\bf{Q}(\bf{I}-\bf{A})^{-1} + \bf{\delta}_X(\bf{I}-\bf{A})^{-1}
$$
Let $\bf{R} = \bf{Q}(\bf{I}-\bf{A})^{-1}_{-(p/2+1)}$ and $\bf{\epsilon_X} = \bf{\delta}_X(\bf{I}-\bf{A})^{-1}_{-(p/2+1)}$ where $-j$ indicates the $j^{th}$ column is removed. Then
$$
\bf{X}_{-Y} = \bf{E}R + \epsilon_X.
$$

## Parameters

### A

The simulation parameters are:

* $p+1$ nodes
    * $p/2$ are potential ancestors of $Y$
    * $p/2$ are potential descendants of $Y$
* $p_0$ nodes are direct parents of $Y$
* $p_0$ nodes are direct children of $Y$

The matrix $A$ is square with $p + 1$ rows (number of nodes above plus one extra for $Y$). The $Y$ node is in $p/2 +1$ row / column of $A$.

### E

* `nobs` observational data
* Knockouts of `np` genes, each knocked out `nko` times
* Knockouts shift mean by `ko_strength`

Thus the columns of $E$ are orthogonal and each column contains `nko` non-zero elements of value `ko_strength`

### R

* `np` $\times$ $p + 1$ matrix with $p/2+1$ column all $0$ (because ko do not effect $Y$ and $Y$ is middle node)
* Each row has exactly one non-zero element, indicating which gene the ko effects.
* Each column of $R$ has at most one non-zero element, because each gene is only experimented on 1 time.

### $\Sigma$

$\Sigma$ induces hidden confounding. Let

$$
\Sigma = 
\begin{pmatrix}
\Sigma_1 & 0 & 0\\
0 & \Sigma_2 & 0\\
0 & 0 & \Sigma_1
\end{pmatrix}
$$

where $\Sigma_1 \in \mathbb{R}^{(p/2 - p_0) \times (p/2 - p_0)}$ and $\Sigma_2 \in \mathbb{R}^{(2p_0+1) \times (2p_0+1)}$. We let

* $\Sigma_{1,ij} = \rho_1^{|i-j|}$
* $\Sigma_{2,ij} = \rho_2^{|i-j|}$


## Functions

The following source is used to simulate from these distributions:

```{r functions,message=FALSE,warning=FALSE}
source("funcs.R")
```


## Simulate and Fit

Load simulation parameters:

```{r parameters}
## before loading this file must run script:
## Rscript 0-params.R
load("0-params.RData")
```



Generate data:

```{r sim-eda}
params <- params_quick[[1]]
pp <- params$pp
p0 <- params$p0
dat <- GenerateData(params$pp,
                    params$p0,
                    params$nobs,
                    params$nko,
                    params$ko_strength,
                    params$np,
                    params$S2,
                    params$st1,
                    params$st2,
                    params$ntop)
X <- dat$X
A <- dat$Abeta$A
beta <- dat$Abeta$beta
E <- dat$ER$E
R <- dat$ER$R
ix <- pp/2+1
colnames(X) <- c(paste0("X",1:(pp/2)),
                 "Y",
                 paste0("X",
                      (pp/2+1):(pp)))
Y <- X[,ix]
X <- X[,-ix]
plot(1:ncol(X),apply(X,2,sd))
ExpInd <- 1*(rowSums(abs(E))!=0)


Xplot <- cbind(X[,(pp/2-p0+1):(pp/2)],Y,X[,(pp/2+1):(pp/2+p0)])
pairs(Xplot,col=ExpInd+1)
pairs(Xplot[ExpInd==0,])
```

Fit estimators on simulated data:

```{r estimators}
fitgm <- glmnet(X,Y)
plot(fitgm,label=TRUE)
fitgm <- cv.glmnet(X,Y)
plot(fitgm)
coefs <- coef(fitgm)

l1_est <- coefs[-1]
plot(beta,l1_est,main="L1")
abline(h=0)

## lasso selection
ix <- coefs[-1]!=0
Xsub <- X[,ix]
ExpInd <- 1*(rowSums(abs(E))!=0)


## fit causal dantzig
fit <- causalDantzig(Xsub,Y,ExpInd)
cd_est <- rep(0,ncol(X))
cd_est[ix] <- coef(fit)[,1]
plot(beta,cd_est,main="CD")
abline(h=0)

## fit ICP
fit <- ICP(Xsub,Y,ExpInd,
           maxNoVariables=10,
           maxNoVariablesSimult=10,
           stopIfEmpty=TRUE,
           showAcceptedSets=FALSE,
           showCompletion=FALSE)
ICPest <- fit$maximinCoefficients
IC <- rep(0,ncol(X))
IC[ix] <- ICPest
plot(beta,IC,main="ICP")
abline(h=0)

## unregularized IV
fitiv <- ivreg.fit(X,Y,E)
plot(beta,coef(fitiv),main="Unregularized IV")

## regularized IV
fitiv <- ivreg.fit(Xsub,Y,E)
iv_est <- rep(0,ncol(X))
iv_est[ix] <- coef(fitiv)
plot(beta,iv_est,main="Regularized IV")

## regularized second stage then first stage
iv_reg2 <- TSLSreg(X,Y,E)
plot(beta,iv_reg2,main="Regularized 2 Stage IV")
```



## Performance Comparison

Compare:

* L1: Lasso regression with tuning parameter chosen by cross validation
* CD: Causal Dantzig on variables chosen by L1 regression
* IV: TSLS with variables chosen by L1 regression
* IV2: TSLS with regularized first and second stages
* ICP: Invariant Causal Prediction

```{r run-sims}
N <- 100
rseeds <- sample(1:10^8,N)
for(ii in 1:length(params_quick)){
  print(paste0("====== Parameters ",ii," ======="))
  res <- mclapply(1:N,FUN=RunSim,
                  params=params_quick[[ii]],
                  rseeds=rseeds,
                  mc.cores=1)
  nused <- vapply(res,function(x){x[[2]]},c(0))
  res <- lapply(res,function(x){x[[1]]})
  cnames <- names(res[[1]])
  res <- matrix(unlist(res),ncol=length(res[[1]]),byrow=TRUE)
  colnames(res) <- cnames
  print(summary(res))
  print(summary(nused))
}
```
